// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "ProjectileComponent.generated.h"

struct ALIVE_API FProjectileInstance
{
	FProjectileInstance(uint16 Key, const FVector& Location = FVector(), const FRotator& Rotation = FRotator())
		: ProjectileID(Key), CurrentLocation(Location), InitRotation(Rotation), ElapsedTime(0.0f), bPendingKill(false)
	{
	}

	// Used to identify the same projectile in the server and client. Generated by client and sent it to server.
	uint16 ProjectileID;
	FVector CurrentLocation;
	FRotator InitRotation;
	float ElapsedTime;
	bool bPendingKill;
};

struct ALIVE_API FServerHitResult
{
	FServerHitResult(): bTraceFinish(false), ElapsedFrames(0)
	{
	}

	bool bTraceFinish;
	int32 ElapsedFrames;
	TArray<class AAliveCharacter*> PossibleHitTargets;
};

struct ALIVE_API FClientHitResult
{
	FClientHitResult(): CheckKey(0), ElapsedFrames(0)
	{
	}

	uint16 CheckKey;
	int32 ElapsedFrames;
	FHitResult HitResult;
};

UENUM(BlueprintType)
enum class EProjectileType : uint8
{
	/** return the hit result instantly while Firing. */
	Hitscan,
	/** Consider the velocity of the Projectile. */
	Velocity,
	/** Consider both the velocity and gravity of the Projectile . */
	VelocityAndGravity
};

/**
 * Provides functional Projectiles based on ray detection.
 * Client generates hit result, than Server checks the hit result sent from client and apply damage.
 * It also works at low projectile speeds, but you are advised to use the server for generating hit result in this case.
 */
UCLASS(ClassGroup=(Alive), hidecategories=(Object,LOD,Lighting,Transform,Sockets,TextureStreaming))
class ALIVE_API UProjectileComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UProjectileComponent();

protected:
	virtual void BeginPlay() override;
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

private:
	UPROPERTY()
	class AAliveWeapon* OwningWeapon;

protected:
	/**
	 * Use a logical tick rate. Ensure that the client and server have the same projectile simulation results.
	 * MaxFrequency is decided by tick rate.
	 */
	UPROPERTY(EditDefaultsOnly, Category = "Alive", meta = (ClampMin = 1, ClampMax = 60))
	int32 UpdateFrequency;
	UPROPERTY(EditDefaultsOnly, Category = "Alive")
	bool bDrawDebug;
	UPROPERTY(BlueprintReadOnly, EditDefaultsOnly, Category = "Alive|Projectile")
	EProjectileType ProjectileType;
	/** How far the projectile can go. (m) */
	UPROPERTY(BlueprintReadOnly, EditDefaultsOnly, Category = "Alive|Projectile", meta = (ClampMin = 1.0f, ClampMax = 3000.0f))
	float Range;
	/** Will not work while the ProjectileType is hitscan. (m/s) */
	UPROPERTY(BlueprintReadOnly, EditDefaultsOnly, Category = "Alive|Projectile", meta = (ClampMin = 1.0f, ClampMax = 1200.0f))
	float Velocity;
	/** Only work while ProjectileType is ProjectileAndGravity. (m/s^2) */
	UPROPERTY(BlueprintReadOnly, EditDefaultsOnly, Category = "Alive|Projectile", meta = (ClampMin = 0.1f, ClampMax = 100.0f))
	float Gravity;

	/** The maximum RTT allowed by the server. Used to calculate WaitHitResultFrames (ms) */
	UPROPERTY(EditDefaultsOnly, Category = "Alive|Network", meta = (ClampMin = 10.0f, ClampMax = 1000.0f))
	float NetworkDelayTolerance;
	/** The maximum Fluctuation allowed by the server. Used to calculate WaitHitResultFrames (ms) */
	UPROPERTY(EditDefaultsOnly, Category = "Alive|Network", meta = (ClampMin = 10.0f, ClampMax = 1000.0f))
	float NetworkFluctuationTolerance;
	/** The maximum Velocity of target object you want to shoot at. Used to calculate WaitHitResultFrames (m/s) */
	UPROPERTY(EditDefaultsOnly, Category = "Alive|Network", meta = (ClampMin = 1.0, ClampMax = 20.0f))
	float TargetMaximumVelocity;

	// Override in blueprint to show visual effects.
	UFUNCTION(BlueprintImplementableEvent)
	void OnProjectileHit(const FHitResult HitResult);

private:
	TArray<FProjectileInstance> ProjectileInstances;

	void TraceAndDrawDebug(TArray<FHitResult>& HitResults, const FVector Start, const FVector End) const;

	void UpdateProjectileOneFrame(FProjectileInstance& Projectile);

	// Only work on the server
	// Hit result generated by the server. Only the TargetActor was saved
	TMap<uint32, FServerHitResult> MapToServerHitResult;
	// Generated by the client and sent to server.
	TArray<FClientHitResult> ClientHitResults;

	UFUNCTION(Server, Reliable)
	void ServerHitResultCheck(uint16 CheckKey, FHitResult HitResult);
	void ServerHitResultCheck_Implementation(uint16 CheckKey, FHitResult HitResult);

	// A temp
	float ElapsedTimeSinceLastUpdate = 0.0f;
	// Based on UpdateFrequency
	float UpdateInterval;
	// Based on Range and velocity
	float ProjectileLifespan;

	// The following two figures are not far apart when the projectile velocity is much greater than target movement speed.
	// The frames that server's hit result should wait for client's hit result.
	int32 ServerWaitHitResultFrames;
	// The frames that client's hit result should wait for server's hit result.
	int32 ClientWaitHitResultFrames;
	// Called in BeginPlay after initializing other data, like UpdateInterval.
	void CalculateWaitHitResultFrames();
};
